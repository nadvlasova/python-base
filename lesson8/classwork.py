import re
# re библиотека регулярных выражений
values = ['abd', 'a34', '234', '1324d']
# из этого списка строк найти образцы, где встречается хоть одна цифра
for value in values: # итерация по всем значениям этого списка
    result = re.search(r'\d', value) # в библиотеке re есть метод search у которого 2 параметра:'\d' - образец который мы ищем и value строка в которой ищем
    # result = '0' in value # такой запрос проверяет есть ли ноль в value        # '\d'- это означает любая цифра
    # result = '0', in value or '1' in value or '2' in value # проверит наличие 1 или 2 или 3 и выдаст True, вместо этого '\d' и все проще
    if result:  # если результат не пустой, значит встретился образец списка где есть любая цифра
        print(value, result)
# a34 <re.Match object; span=(1, 2), match='3'> #re.Match object - спец объект, span=(1, 2)-его находка на позиции 1,2, match='3' - а это первое, что нашел
# 234 <re.Match object; span=(0, 1), match='2'>  # span=(0, 1) промежуток на котором находна, правая граница не включена
# 1324d <re.Match object; span=(0, 1), match='1'>
    else:
        print(value, 'ничего не найдено') # если ничего не нашла
# abd ничего не найдено
# a34 <re.Match object; span=(1, 2), match='3'>
# 234 <re.Match object; span=(0, 1), match='2'>
# 1324d <re.Match object; span=(0, 1), match='1'>

# \ кватирующий символ нужен, чтобы простые символы воспринимались не как служебные для одного слеша придется поставить ещё один
# с регул. выражениями слэшей много, поэтому придумали модификатор r и тогда строка воспринимается сырой и управляющие символы воспринимаются как простые